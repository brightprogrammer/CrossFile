Date : Mon, 10th June 2024
Author : Siddharth Mishra

# Introducing The CrossFile Type (XFT) Virtual Machine (VM)

CrossFile Type VM is a vm that is made for executing code generated by `xftc`.
`xftc` is a type description compiler that reads string description of structures
and other types in C and generates bytecode for XftVm.

## Motivation

I've been experimenting with ideas on how to load binary files based on a given
file format. Previous idea was to create a language named [StAsm](./StructureAssembly.md)
and create a transpiler to convert `StAsm` code to C code and then use the generated
code wherever we want to read that file format.

This approach of `StAsm` not only adds another build step, but is also an invader for
those using their own build system of choice. If I myself (the creator) don't like this
bug/feature, I know many won't like it as well.

The solution must involve something where type descriptions are compiled without any
extra step (until unless user wants that). This meant the solution must revolve somewhere
around parsing C code. This created the idea of having macros that stringify the type
definitons and annotation macros that don't do anything and are just there for `xftc` 
to be able to understand and generate proper bytecode.

## The `xftc`

`xftc` is a (to be implemented at the time of writing) run-time compiler for type descriptions
provided in an annotated C code. This does not require any separate build step and generates
all instructions only when it's asked to.

This solution fits better in the big picture because the compiled instructions can later
on also be serialized to a separate binary file containing XftVm bytecode. Now since this VM
bytecode is platform-independent, it can be executed by loading again and again on any platform
without recompilation. The only thing required is XftVm, which will work automatically if
user code is compiled with it.

In very far future, we can also expect it to generate targeted platform optimized code,
that works on a specific platform but is very fast compared to the VM.

## The XftVm

`XftVm` is a virtual machine that performs the actual loading of binary file formats.
There exists multiple streams from with XftVm can read data, allocate proper memory
and read data into it from the stream. XftVm also has instructions to compute the size
of a structure or an array at runtime. This allows for automatic loading of all
structures.

Since XftVm is the one initializing the data, it also knows how to de-initialize it.
This means you just need to ask and it shall be done!

## Design

XftVm is designed to execute two levels of loaders. First one is the `FileLoader`,
or `XftFileLoader` as it's publicly named within the code, and second one is `TypeLoader`,
or `XftTypeLoader` as it's named publicly within the code. One can directly execute
any one of those depending on what they want to load. Both the structures are opaque
on inclusion from `Anvie/CrossFile/Xft` and 

A `FileLoader` contains all the `TypeLoader` instances required to load the file.
A `TypeLoader` contains multiple `InsnBlock` objects and references to `TypeLoader`
objects withing the parent `FileLoader` or any other object that contains an array
of `TypeLoader` objects and can provide reference to those type loaders.

The `InsnBlock` object stores a contiguous sequence of instructions without any break,
and jumps between these blocks are performed by indexing into the array of `InsnBlock`.

## Examples

```c
/* just one single minimal header */
#include <Anvie/CrossFile/Xft.h>

XFT_STRUCT (XfOtfTableRecord, {
    Uint32 table_tag;
    Uint32 checksum;
    Uint32 offset;

    XFT_DOC ("length of table record field")
    Uint32 length;
});

XFT_STRUCT (XfOtfTableDir, {
    Uint32 sfnt_version;
    Uint16 num_tables;
    Uint16 search_range;
    Uint16 entry_selector;
    Uint16 range_shift;

    /*          vector elem type  vector name    vector size expr */
    XFT_VECTOR (XfOtfTableRecord, table_records, num_tables);
});

XFT_STRUCT (XfOtfOs2, {
    Uint16 version;
    Int16  x_avg_char_width;
    Uint16 weight_class;
    Uint16 width_class;
    Uint16 type;
    Int16  y_subscript_x_size;
    Int16  y_subscript_y_size;
    Int16  y_subscript_x_offset;
    Int16  y_subscript_y_offset;
    Int16  y_superscript_x_size;
    Int16  y_superscript_y_size;
    Int16  y_superscript_x_offset;
    Int16  y_superscript_y_offset;
    Int16  y_strikeout_size;
    Int16  y_strikeout_position;
    Int16  family_class;
    Uint8  panose[10];
    Uint32 unicode_range[4];
    Char   vend_id[4];
    Uint16 selection;
    Uint16 first_char_index;
    Uint16 last_char_index;
    Int16  typo_ascender;
    Int16  typo_descender;
    Int16  typo_line_gap;
    Uint16 win_ascent;
    Uint16 win_descent;

    /* v1 */
    XFT_IF (version >= 1) Uint32 code_page_range[2];

    /* v2, v3, v4*/
    XFT_IF (version >= 2) Int16  x_height;
    XFT_IF (version >= 2) Int16  cap_height;
    XFT_IF (version >= 2) Uint16 default_char;
    XFT_IF (version >= 2) Uint16 break_char;
    XFT_IF (version >= 2) Uint16 max_context;

    /* v5 */
    XFT_IF (version == 5) Uint16 lower_optical_point_size;
    XFT_IF (version == 5) Uint16 upper_optical_point_size;
});
```

The `XFT_IF` macro is an annotation provided for `xftc` to emit conditional code
on whether to read the field or not based on given expression. `XFT_VECTOR` is
adds a pointer and size of vector variable to the struct definition, and instructs
`xftc` to generate code for loading a vector after that entry. `XFT_DOC` can be used
to annotate fields with documentation information for better code readability and
also for pretty printing.

In future there can be multiple other annotation macros as well, like, at what address
should the read be performed.

## Future Scope

Understanding of binary file formats is very important for someone who has to deal
with them. The generated compiled bytecode files can be used with an interactive
tool to interactively read and understand how a particular file format works.
If the file format descriptions are well documented then those documentation can
be printed in interactive mode as well. Interactive mode can also be used for
debugging the file format or the file itself.
